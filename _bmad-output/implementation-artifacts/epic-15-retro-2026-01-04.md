# Epic 15 Retrospective - Codebase Intelligence

**Date:** 2026-01-04
**Epic:** 15 - Codebase Intelligence
**Status:** Complete

## Participants
- Bob (Scrum Master)
- Alice (Product Owner)
- Charlie (Senior Dev)
- Dana (QA Engineer)
- Elena (Junior Dev)
- Chris (Project Lead)

## Epic Summary
Epic 15 delivered codebase hallucination detection and codebase RAG context indexing. The team implemented AST-based symbol extraction, multi-tenant caching, import/path/API validation, and code search with graph enrichment. The epic focused on trust, safety, and grounding in codebase intelligence.

## Delivery Metrics
- Stories completed: 2/2 (100%)
- Story points: Not tracked
- Duration: Not tracked
- Blockers encountered: None explicitly recorded in story artifacts
- Technical debt items: None explicitly recorded; review follow-ups captured below
- Test coverage: Not reported in story artifacts
- Production incidents: None recorded

## What Went Well
- **Security and correctness were prioritized.** Critical vulnerabilities (path traversal, SSRF, and cache invalidation gaps) were detected and fixed promptly.
- **Multi-layer validation was delivered.** Symbol, path, API endpoint, and import validation shipped with confidence scoring and actionable suggestions.
- **Codebase RAG indexing landed end-to-end.** Scanner, chunker, graph relationships, and search endpoints were implemented and approved.
- **Reviews were thorough and constructive.** Iterative reviews surfaced quality gaps and drove meaningful hardening improvements.

## Challenges and Friction Points
- **Path and repo validation edge cases.** Multiple fixes were required to lock down traversal and base-path boundaries.
- **Incremental indexing correctness.** Early approach overwrote cached symbol tables and required rework.
- **API validation wiring.** OpenAPI routing validation needed explicit wiring and source-based extraction.
- **Performance evidence gaps.** Performance targets were stated but benchmarking artifacts were not recorded.

## Minor Issues & Suggestions
1. **Import placement in codebase route.** `rate_limit_exceeded` import should live with other imports for consistency. (Low impact, style-only)
2. **Unbounded regex matching.** Add a configurable max symbol extraction limit for very large responses to avoid pathological workloads. (Low impact, edge cases)
3. **Redis client typing.** Replace forward-reference + `type: ignore` with `TYPE_CHECKING` import or Protocol for cleaner typing. (Low impact, quality)
4. **Neo4j relationship creation batching.** Current per-relationship creation is O(n) network calls; batch for large repos. (Medium impact, perf)
5. **API docs reference.** Add OpenAPI examples or a dedicated API reference for new codebase endpoints. (Low impact, DX)

## Questions & Clarifications
1. **Dependency scanning strategy.** Should import validation also check installed packages (e.g., `importlib.metadata`) in addition to declared deps?
2. **Symbol table memory usage.** Should we document expected memory per symbol and validate with a real-world load test?
3. **Tree-sitter version compatibility.** Any known ABI mismatches requiring tighter pinning across core and language grammars?

## Performance Considerations
**Measured signals:**
- Detection target: < 100ms for typical responses.
- Slow warning threshold: 2000ms (`CODEBASE_DETECTION_SLOW_MS`).
- Symbol table cache TTL: 3600s.

**Potential bottlenecks:**
- Large repository indexing lacks progress reporting and cancellation.
- Embeddings are generated synchronously during indexing.
- Regex extraction can be expensive with very large responses.

**Recommendations:**
- Consider async/parallel embedding generation for large file sets.
- Consider pagination/streaming for large indexing operations.
- Add a configurable max symbol validation cap to prevent worst-case regex loops.

## Security Assessment
**Well-protected:**
- Path traversal mitigated via `resolve_repo_path()` and containment checks.
- Multi-tenancy enforced with tenant scoping.
- Indexing rate limiting in place.
- Input validation via Pydantic models.

**Areas to monitor:**
- Regex DoS potential with crafted input (low likelihood, but possible).
- Memory exhaustion from very large symbol tables (guardrails exist; confirm with load tests).
- File system access requires `CODEBASE_ALLOWED_BASE_PATH` in production.

**Recommendations:**
- Document `CODEBASE_ALLOWED_BASE_PATH` as mandatory in production deployments.
- Consider adding operation timeouts or cancellation hooks for large codebases.

## Potential Issues & Concerns
1. **Memory consumption risk.** SymbolTable stores every symbol with no enforced cap even though `CODEBASE_SYMBOL_TABLE_MAX_SYMBOLS=200000` is configured. Large repositories (100k+ symbols) could exhaust available RAM unless we evict old entries or warn when approaching limits. (Location: `symbol_table.py`, `detector.py`)
2. **N+1-style indexing writes.** Indexing iterates per file/symbol and issues individual writes/chunk creations, making the workload expensive for large codebases. Batch chunk inserts (e.g., multi-row INSERT/COPY), group Neo4j relationship writes, and instrument query counts. (Location: `codebase/indexing/indexer.py`)
3. **Regex performance on large responses.** `_validate_symbols` performs multiple regex passes on the same response text, which is costly for 100k+ responses. Combine patterns, short-circuit long strings, or limit processing to the first N characters with warnings. (Location: `codebase/detector.py`)
4. **Rate limiting gaps for indexing.** The environment defines separate max/window values, but expensive indexing endpoints need explicit enforcement (and ideally different limits from validation). Consider request queuing to prevent resource exhaustion. (Location: `api/routes/codebase.py`)
5. **Incomplete error context.** Validation errors currently lack precise location/snippet context, making debugging near the 100k char limit difficult. Include `location_in_response`, short snippets, and request IDs in responses. (Location: `api/routes/codebase.py`)

## Potential Bugs
1. **Unicode handling in file reads.** The indexer reads files strictly as UTF-8, so files with other encodings or binary contents may raise `UnicodeDecodeError`. Add encoding detection or gracefully skip unsupported files. (Location: `codebase/indexing/indexer.py`)
2. **Async file operations inconsistent.** `scan_directory` uses async iteration but still calls synchronous `extractor.extract_from_file`, blocking the loop. Either use `aiofiles`/async reads or drop the async signature to avoid hidden bottlenecks. (Location: `codebase/detector.py`)
3. **Cache race condition during indexing.** Incremental indexing may read a cached symbol table while another writer re-caches it, overwriting in-flight changes. Introduce cache versioning, locking, or invalidation hooks tied to repo updates. (Location: `codebase/symbol_table.py`)

## Key Lessons Learned
1. **Security checks must be consistent across all entry points.** Base-path constraints and path resolution belong in shared utilities and every endpoint that accepts repo paths.
2. **Cache correctness is as important as cache presence.** Incremental indexing needs explicit merge semantics and safe removal of stale symbols.
3. **Declared dependency context improves import validation fidelity.** Repo manifests should be treated as first-class inputs to import validation.
4. **Decorator parsing must read source, not docstrings.** Correct API route extraction needs actual source analysis or explicit symbol metadata.

## Review Follow-Through (Prior Epic)
- Previous epic retrospective for Epic 14 not found in expected location. No prior action items could be verified.

## Next Epic Preview
- Next epic definition not found in the expected output folder. Sprint status indicates Epic 16 is planned; ensure the artifact is discoverable before kickoff.

## Action Items
1. **Add performance benchmarks and record results** for detector and indexing paths (Owner: Dana, QA Engineer)
2. **Add regression tests for path traversal and base-path enforcement** across validation and indexing endpoints (Owner: Charlie, Senior Dev)
3. **Document operational guardrails** for indexing rate limits and symbol table cache thresholds (Owner: Paige, Tech Writer)
4. **Add OpenAPI validation coverage** for endpoint extraction and routing correctness (Owner: Amelia, Developer Agent)
5. **Define a max-symbol validation cap** for detector regex extraction (Owner: Amelia, Developer Agent)
6. **Investigate batching Neo4j relationship creation** for indexing throughput (Owner: Charlie, Senior Dev)
7. **Publish API reference examples** for `/codebase/index` and `/codebase/search` (Owner: Paige, Tech Writer)
8. **Decide dependency scanning policy** (declared-only vs installed packages) and document it (Owner: Chris, Project Lead)
9. **Document production requirement for `CODEBASE_ALLOWED_BASE_PATH`** (Owner: Paige, Tech Writer)
10. **Enforce symbol count cap + observability** (Owner: Charlie, Senior Dev)
11. **Batch chunk/relationship inserts and add DB metrics** (Owner: Amelia, Developer Agent)
12. **Enhance validation errors with context/snippets** (Owner: Dana, QA Engineer)
13. **Confirm indexing rate limits + queuing policy** (Owner: Chris, Project Lead)
14. **Add encoding resilience for very large codebases** (Owner: Charlie, Senior Dev)
15. **Review async file handling in detector scan** (Owner: Amelia, Developer Agent)
16. **Add cache versioning/locking for incremental updates** (Owner: Charlie, Senior Dev)

## Preparation Tasks for Next Epic
- Ensure Epic 16 planning artifacts are discoverable in the expected outputs (Owner: Bob, Scrum Master)
- Review Codebase Intelligence limitations and update developer-facing docs where needed (Owner: Paige, Tech Writer)

## Critical Path Items
- None identified. Quality follow-ups above should be completed before heavy expansion of codebase indexing usage.

## Readiness Assessment
- **Testing & Quality:** Tests exist for core modules; performance benchmarks and security regression tests are still needed.
- **Deployment:** No deployment blockers recorded.
- **Stakeholder Acceptance:** Not explicitly recorded; assume internal acceptance unless stated otherwise.
- **Technical Health:** Stable after review hardening; continued validation coverage recommended.

## Commitments
- Maintain security-first review posture for file system and indexing features.
- Add measurable performance evidence for detector and indexing flows.
- Improve documentation discoverability for upcoming epic planning.

---

Bob (Scrum Master): "Epic 15 delivered a high-trust foundation for codebase intelligence. Let's carry these lessons into the next epic with the same rigor."
