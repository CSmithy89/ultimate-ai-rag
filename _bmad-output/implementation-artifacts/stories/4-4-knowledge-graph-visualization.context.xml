<?xml version="1.0" encoding="UTF-8"?>
<!--
  Story Context File for Story 4.4: Knowledge Graph Visualization
  Generated: 2025-12-28
  Epic: 4 - Knowledge Ingestion Pipeline

  This file provides comprehensive implementation context for the dev agent.
  Read this BEFORE implementing the story.
-->
<story-context>
  <metadata>
    <story-id>4.4</story-id>
    <story-title>Knowledge Graph Visualization</story-title>
    <story-file>_bmad-output/implementation-artifacts/stories/4-4-knowledge-graph-visualization.md</story-file>
    <epic>Epic 4: Knowledge Ingestion Pipeline</epic>
    <status>ready-for-dev</status>
    <generated>2025-12-28</generated>
    <dependencies>
      <dependency status="done">4.1 - URL Documentation Crawling</dependency>
      <dependency status="done">4.2 - PDF Document Parsing</dependency>
      <dependency status="done">4.3 - Agentic Entity Extraction</dependency>
    </dependencies>
  </metadata>

  <story-summary>
    <description>
      As a data engineer, I want to visualize the current state of the knowledge graph,
      so that I can identify gaps, orphan nodes, and data quality issues.
    </description>
    <scope>
      - Backend: Create Knowledge Graph API endpoints for retrieving graph data, stats, and orphan nodes
      - Frontend: React Flow visualization component with custom nodes/edges, filtering, and stats panel
      - Integration: TanStack Query hooks for data fetching following project conventions
    </scope>
  </story-summary>

  <acceptance-criteria>
    <criterion id="AC1">
      Given entities and relationships exist in Neo4j, when the user requests graph data via
      GET /api/v1/knowledge/graph, then the API returns nodes with id, label, type, and properties
      along with edges containing source, target, type, and properties.
    </criterion>
    <criterion id="AC2">
      Given the API has returned graph data, when the React Flow component renders, then nodes
      are displayed with their labels and type-based colors following the design system
      (Person: Blue, Organization: Emerald, Technology: Indigo, Concept: Violet, Location: Amber).
    </criterion>
    <criterion id="AC3">
      Given the graph is rendered, when edges are displayed, then each edge shows its relationship
      type label (MENTIONS, AUTHORED_BY, PART_OF, USES, RELATED_TO).
    </criterion>
    <criterion id="AC4">
      Given the graph visualization is displayed, when the user interacts with the canvas, then
      they can zoom in/out, pan across the graph, and click to select individual nodes.
    </criterion>
    <criterion id="AC5">
      Given nodes exist in the knowledge graph, when the orphan detection logic runs, then nodes
      with zero relationships are identified and highlighted in the warning color (Amber-400/Orange).
    </criterion>
    <criterion id="AC6">
      Given the graph contains multiple entity types, when the user applies entity type or
      relationship filters, then only nodes/edges matching the selected criteria are displayed.
    </criterion>
    <criterion id="AC7">
      Given the user requests graph statistics via GET /api/v1/knowledge/stats, then the API
      returns nodeCount, edgeCount, and orphanCount with proper tenant_id filtering.
    </criterion>
  </acceptance-criteria>

  <backend-implementation>
    <overview>
      Create a new knowledge.py router with three endpoints. All endpoints MUST include
      tenant_id filtering for multi-tenancy. Use existing Neo4j client patterns from db/neo4j.py.
    </overview>

    <files-to-create>
      <file path="backend/src/agentic_rag_backend/api/routes/knowledge.py">
        <purpose>Knowledge Graph API endpoints</purpose>
        <endpoints>
          <endpoint method="GET" path="/api/v1/knowledge/graph">
            <description>Fetch graph data for visualization</description>
            <query-params>
              <param name="tenant_id" type="UUID" required="true"/>
              <param name="limit" type="int" default="100"/>
              <param name="offset" type="int" default="0"/>
              <param name="entity_type" type="string" required="false"/>
              <param name="relationship_type" type="string" required="false"/>
              <param name="date_from" type="datetime" required="false"/>
            </query-params>
            <response-format><![CDATA[
{
  "data": {
    "nodes": [
      {"id": "uuid", "label": "Entity Name", "type": "Technology", "properties": {...}, "isOrphan": false}
    ],
    "edges": [
      {"id": "uuid", "source": "uuid1", "target": "uuid2", "type": "USES", "label": "USES", "properties": {...}}
    ]
  },
  "meta": {"requestId": "uuid", "timestamp": "ISO8601"}
}
            ]]></response-format>
          </endpoint>
          <endpoint method="GET" path="/api/v1/knowledge/stats">
            <description>Get graph statistics</description>
            <query-params>
              <param name="tenant_id" type="UUID" required="true"/>
            </query-params>
            <response-format><![CDATA[
{
  "data": {
    "nodeCount": 1500,
    "edgeCount": 3200,
    "orphanCount": 12,
    "entityTypeCounts": {"Person": 200, "Technology": 500, ...},
    "relationshipTypeCounts": {"USES": 800, "MENTIONS": 500, ...}
  },
  "meta": {...}
}
            ]]></response-format>
          </endpoint>
          <endpoint method="GET" path="/api/v1/knowledge/orphans">
            <description>List orphan nodes (nodes with no relationships)</description>
            <query-params>
              <param name="tenant_id" type="UUID" required="true"/>
              <param name="limit" type="int" default="50"/>
            </query-params>
          </endpoint>
        </endpoints>
      </file>
    </files-to-create>

    <files-to-modify>
      <file path="backend/src/agentic_rag_backend/main.py">
        <modification>Register knowledge_router in app.include_router()</modification>
        <pattern>
          Import: from .api.routes import knowledge_router
          Register: app.include_router(knowledge_router, prefix="/api/v1")
        </pattern>
      </file>
      <file path="backend/src/agentic_rag_backend/api/routes/__init__.py">
        <modification>Export knowledge_router</modification>
      </file>
      <file path="backend/src/agentic_rag_backend/models/graphs.py">
        <modification>Add visualization-specific response models</modification>
        <models-to-add>
          <model name="GraphNode">Fields: id, label, type, properties, isOrphan</model>
          <model name="GraphEdge">Fields: id, source, target, type, label, properties</model>
          <model name="GraphData">Fields: nodes (list[GraphNode]), edges (list[GraphEdge])</model>
          <model name="GraphStats">Fields: nodeCount, edgeCount, orphanCount, entityTypeCounts, relationshipTypeCounts</model>
          <model name="GraphQueryParams">Fields: tenant_id, limit, offset, entity_type, relationship_type, date_from</model>
        </models-to-add>
      </file>
    </files-to-modify>

    <neo4j-queries>
      <query name="fetch_graph_data"><![CDATA[
MATCH (n:Entity)
WHERE n.tenant_id = $tenant_id
OPTIONAL MATCH (n)-[r]->(m:Entity)
WHERE m.tenant_id = $tenant_id
RETURN n, r, m
SKIP $offset
LIMIT $limit
      ]]></query>
      <query name="fetch_with_entity_type_filter"><![CDATA[
MATCH (n:Entity)
WHERE n.tenant_id = $tenant_id AND n.type = $entity_type
OPTIONAL MATCH (n)-[r]->(m:Entity)
WHERE m.tenant_id = $tenant_id
RETURN n, r, m
SKIP $offset
LIMIT $limit
      ]]></query>
      <query name="detect_orphan_nodes"><![CDATA[
MATCH (n:Entity)
WHERE n.tenant_id = $tenant_id
AND NOT (n)-[]-()
RETURN n
      ]]></query>
      <query name="get_graph_statistics"><![CDATA[
MATCH (n:Entity) WHERE n.tenant_id = $tenant_id
WITH count(n) as nodeCount
MATCH ()-[r]->() WHERE startNode(r).tenant_id = $tenant_id
WITH nodeCount, count(r) as edgeCount
MATCH (orphan:Entity) WHERE orphan.tenant_id = $tenant_id AND NOT (orphan)-[]-()
RETURN nodeCount, edgeCount, count(orphan) as orphanCount
      ]]></query>
      <query name="entity_type_counts"><![CDATA[
MATCH (n:Entity) WHERE n.tenant_id = $tenant_id
RETURN n.type as type, count(n) as count
      ]]></query>
      <query name="relationship_type_counts"><![CDATA[
MATCH (n:Entity)-[r]->(m:Entity)
WHERE n.tenant_id = $tenant_id
RETURN type(r) as type, count(r) as count
      ]]></query>
    </neo4j-queries>

    <existing-patterns>
      <pattern name="api-response-wrapper" source="api/routes/ingest.py">
        <code><![CDATA[
def success_response(data: Any) -> dict[str, Any]:
    return {
        "data": data,
        "meta": {
            "requestId": str(uuid4()),
            "timestamp": datetime.utcnow().isoformat() + "Z",
        },
    }
        ]]></code>
      </pattern>
      <pattern name="dependency-injection" source="api/routes/ingest.py">
        <code><![CDATA[
from agentic_rag_backend.db.neo4j import Neo4jClient, get_neo4j_client

async def get_neo4j() -> Neo4jClient:
    """Get Neo4j client dependency."""
    settings = load_settings()
    return await get_neo4j_client(
        uri=settings.neo4j_uri,
        user=settings.neo4j_user,
        password=settings.neo4j_password,
    )
        ]]></code>
      </pattern>
      <pattern name="error-handling" source="core/errors.py">
        <description>Use AppError subclasses for structured errors with RFC 7807 format</description>
      </pattern>
    </existing-patterns>

    <test-file>backend/tests/api/test_knowledge.py</test-file>
  </backend-implementation>

  <frontend-implementation>
    <overview>
      Create React Flow-based knowledge graph visualization with custom node/edge components,
      filtering controls, and TanStack Query data fetching. Follow project naming conventions.
    </overview>

    <dependencies-to-install>
      <command>cd frontend &amp;&amp; pnpm add reactflow @tanstack/react-query</command>
      <note>Also install: pnpm add zod (for validation if not present)</note>
    </dependencies-to-install>

    <files-to-create>
      <file path="frontend/src/components/graphs/KnowledgeGraph.tsx">
        <purpose>Main React Flow container component</purpose>
        <features>
          - Force-directed layout
          - Zoom, pan, node selection controls
          - Minimap and Controls panel
          - Integration with custom node/edge types
        </features>
        <code-example><![CDATA[
import ReactFlow, {
  MiniMap,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
} from 'reactflow';
import 'reactflow/dist/style.css';
import { EntityNode } from './EntityNode';
import { RelationshipEdge } from './RelationshipEdge';

const nodeTypes = { entity: EntityNode };
const edgeTypes = { relationship: RelationshipEdge };

export function KnowledgeGraph({ data }: { data: GraphData }) {
  const [nodes, setNodes, onNodesChange] = useNodesState(transformNodes(data.nodes));
  const [edges, setEdges, onEdgesChange] = useEdgesState(transformEdges(data.edges));

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      nodeTypes={nodeTypes}
      edgeTypes={edgeTypes}
      fitView
    >
      <Controls />
      <MiniMap />
      <Background />
    </ReactFlow>
  );
}
        ]]></code-example>
      </file>

      <file path="frontend/src/components/graphs/EntityNode.tsx">
        <purpose>Custom node component with entity type coloring</purpose>
        <features>
          - Entity type color coding per design system
          - Display node label and type badge
          - Orphan node highlighting (Amber-400 border/glow)
          - Node selection state styling
        </features>
      </file>

      <file path="frontend/src/components/graphs/RelationshipEdge.tsx">
        <purpose>Custom edge component with relationship labels</purpose>
        <features>
          - Display relationship type labels on edges
          - Optional color coding by relationship type
          - Edge selection state
        </features>
      </file>

      <file path="frontend/src/components/graphs/GraphFilterControls.tsx">
        <purpose>Filter UI controls for graph</purpose>
        <features>
          - Entity type multi-select filter (Person, Organization, Technology, Concept, Location)
          - Relationship type filter
          - Orphan-only toggle filter
          - Search/filter by entity name
        </features>
      </file>

      <file path="frontend/src/hooks/use-knowledge-graph.ts">
        <purpose>TanStack Query hooks for graph data</purpose>
        <hooks>
          <hook name="useKnowledgeGraph">Fetch graph data with filtering options</hook>
          <hook name="useKnowledgeStats">Fetch graph statistics</hook>
          <hook name="useKnowledgeOrphans">Fetch orphan nodes list</hook>
        </hooks>
        <code-example><![CDATA[
import { useQuery } from '@tanstack/react-query';
import { api } from '@/lib/api';
import type { GraphQueryOptions } from '@/types/graphs';

export function useKnowledgeGraph(options?: GraphQueryOptions) {
  return useQuery({
    queryKey: ['knowledge', 'graph', options],
    queryFn: () => api.knowledge.getGraph(options),
    staleTime: 30000, // 30 seconds
  });
}

export function useKnowledgeStats(tenantId: string) {
  return useQuery({
    queryKey: ['knowledge', 'stats', tenantId],
    queryFn: () => api.knowledge.getStats(tenantId),
    staleTime: 60000, // 1 minute
  });
}

export function useKnowledgeOrphans(tenantId: string, limit?: number) {
  return useQuery({
    queryKey: ['knowledge', 'orphans', tenantId, limit],
    queryFn: () => api.knowledge.getOrphans(tenantId, limit),
  });
}
        ]]></code-example>
      </file>

      <file path="frontend/src/app/(features)/knowledge/page.tsx">
        <purpose>Knowledge graph page</purpose>
        <features>
          - Integrate KnowledgeGraph component
          - Stats summary panel
          - Filter controls
          - Loading and error states (skeleton, error display)
        </features>
      </file>

      <file path="frontend/src/types/graphs.ts">
        <purpose>TypeScript types for graph data</purpose>
        <types>
          <type name="GraphNode">id, label, type, properties, isOrphan</type>
          <type name="GraphEdge">id, source, target, type, label, properties</type>
          <type name="GraphData">nodes, edges</type>
          <type name="GraphStats">nodeCount, edgeCount, orphanCount, entityTypeCounts, relationshipTypeCounts</type>
          <type name="GraphQueryOptions">tenantId, limit, offset, entityType, relationshipType, dateFrom</type>
          <type name="EntityType">'Person' | 'Organization' | 'Technology' | 'Concept' | 'Location'</type>
          <type name="RelationshipType">'MENTIONS' | 'AUTHORED_BY' | 'PART_OF' | 'USES' | 'RELATED_TO'</type>
        </types>
      </file>
    </files-to-create>

    <files-to-modify>
      <file path="frontend/src/lib/api.ts">
        <modification>Add knowledge graph API methods</modification>
        <methods>
          <method>api.knowledge.getGraph(options: GraphQueryOptions): Promise&lt;GraphData&gt;</method>
          <method>api.knowledge.getStats(tenantId: string): Promise&lt;GraphStats&gt;</method>
          <method>api.knowledge.getOrphans(tenantId: string, limit?: number): Promise&lt;GraphNode[]&gt;</method>
        </methods>
      </file>
    </files-to-modify>

    <test-file>frontend/__tests__/components/knowledge-graph.test.tsx</test-file>
  </frontend-implementation>

  <design-system>
    <entity-colors>
      <color entity="Person" hex="#3B82F6" tailwind="blue-500">Blue-500</color>
      <color entity="Organization" hex="#10B981" tailwind="emerald-500">Emerald-500</color>
      <color entity="Technology" hex="#6366F1" tailwind="indigo-500">Indigo-500</color>
      <color entity="Concept" hex="#8B5CF6" tailwind="violet-500">Violet-500</color>
      <color entity="Location" hex="#F59E0B" tailwind="amber-500">Amber-500</color>
      <color entity="orphan" hex="#F97316" tailwind="orange-500">Orange-500 (warning highlight)</color>
    </entity-colors>
    <color-constant-code><![CDATA[
// frontend/src/components/graphs/EntityNode.tsx
const entityColors: Record<string, string> = {
  Person: '#3B82F6',        // Blue-500
  Organization: '#10B981',   // Emerald-500
  Technology: '#6366F1',     // Indigo-500
  Concept: '#8B5CF6',        // Violet-500
  Location: '#F59E0B',       // Amber-500
  orphan: '#F97316',         // Orange-500 (warning)
};

// Tailwind classes alternative
const entityColorClasses: Record<string, string> = {
  Person: 'bg-blue-500 border-blue-600',
  Organization: 'bg-emerald-500 border-emerald-600',
  Technology: 'bg-indigo-500 border-indigo-600',
  Concept: 'bg-violet-500 border-violet-600',
  Location: 'bg-amber-500 border-amber-600',
  orphan: 'border-orange-400 ring-2 ring-orange-400/50', // Orphan highlight
};
    ]]></color-constant-code>
    <typography>
      <font use="headings">Inter (Sans-serif)</font>
      <font use="body">Inter</font>
      <font use="code">JetBrains Mono</font>
    </typography>
    <ux-principles>
      <principle>Radical Transparency: Always show the source, the path, and the reasoning</principle>
      <principle>Standardized Aesthetics: Default UI components must be visually neutral and high-quality</principle>
    </ux-principles>
  </design-system>

  <coding-conventions>
    <python>
      <rule>Functions: snake_case</rule>
      <rule>Classes: PascalCase</rule>
      <rule>Constants: SCREAMING_SNAKE_CASE</rule>
      <rule>Files: snake_case.py</rule>
    </python>
    <typescript>
      <rule>Functions: camelCase</rule>
      <rule>Components: PascalCase (file and component name match)</rule>
      <rule>Hooks: use-hook-name.ts with useHookName export</rule>
    </typescript>
    <api>
      <rule>Success response: {"data": {...}, "meta": {"requestId": "uuid", "timestamp": "ISO8601"}}</rule>
      <rule>Error response: RFC 7807 Problem Details format</rule>
    </api>
    <database>
      <rule>EVERY query MUST include tenant_id filtering for multi-tenancy</rule>
      <rule>Neo4j node labels: PascalCase singular</rule>
      <rule>Neo4j relationships: SCREAMING_SNAKE_CASE</rule>
    </database>
    <frontend>
      <rule>ALWAYS use TanStack Query for data fetching, NEVER raw fetch()</rule>
      <rule>Loading state pattern: if (isLoading) return &lt;Skeleton /&gt;</rule>
      <rule>Error state pattern: if (error) return &lt;ErrorDisplay error={error} /&gt;</rule>
    </frontend>
  </coding-conventions>

  <existing-code-reference>
    <backend>
      <file path="backend/src/agentic_rag_backend/db/neo4j.py">
        <description>Neo4j async client - use existing patterns for session management and queries</description>
        <key-methods>
          - get_neo4j_client(): Get global client instance
          - get_graph_stats(tenant_id): Get node/edge counts (extend for visualization)
          - create_entity(), get_entity(), find_similar_entity(): Entity operations
        </key-methods>
      </file>
      <file path="backend/src/agentic_rag_backend/models/graphs.py">
        <description>Existing graph models including EntityType, RelationshipType enums</description>
        <key-models>
          - EntityType: Person, Organization, Technology, Concept, Location
          - RelationshipType: MENTIONS, AUTHORED_BY, PART_OF, USES, RELATED_TO
          - Neo4jEntity, Neo4jRelationship: Storage models
        </key-models>
      </file>
      <file path="backend/src/agentic_rag_backend/api/routes/ingest.py">
        <description>Reference for API patterns - success_response(), dependency injection, error handling</description>
      </file>
      <file path="backend/src/agentic_rag_backend/core/errors.py">
        <description>Error classes and RFC 7807 handler - may need to add GRAPH_QUERY_ERROR</description>
      </file>
    </backend>
    <frontend>
      <file path="frontend/app/layout.tsx">
        <description>Root layout - providers may need TanStack QueryClientProvider</description>
      </file>
      <file path="frontend/package.json">
        <description>Current dependencies - add reactflow, @tanstack/react-query</description>
      </file>
    </frontend>
  </existing-code-reference>

  <performance-considerations>
    <consideration>Default limit of 100 nodes to prevent UI overload</consideration>
    <consideration>Use pagination for large graphs (offset/limit)</consideration>
    <consideration>Consider implementing graph subgraph expansion (click node to load neighbors)</consideration>
    <consideration>React Flow handles large graphs well with virtualization</consideration>
    <consideration>Use query caching with TanStack Query (staleTime: 30-60 seconds)</consideration>
  </performance-considerations>

  <references>
    <reference type="tech-spec">_bmad-output/epics/epic-4-tech-spec.md#34-story-44-knowledge-graph-visualization</reference>
    <reference type="architecture">_bmad-output/architecture.md</reference>
    <reference type="project-context">_bmad-output/project-context.md</reference>
    <reference type="ux-design">_bmad-output/project-planning-artifacts/ux-design-specification.md</reference>
    <reference type="epics">_bmad-output/project-planning-artifacts/epics.md</reference>
    <reference type="story-4-3">_bmad-output/implementation-artifacts/stories/4-3-agentic-entity-extraction.md</reference>
    <reference type="external">https://reactflow.dev/</reference>
    <reference type="external">https://tanstack.com/query/latest</reference>
  </references>
</story-context>
